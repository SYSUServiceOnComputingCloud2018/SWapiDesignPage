# 项目小结

16340240吴天扬

我在这次项目中主要负责的是数据库读写API的相关开发与对swapi数据的采集。应该说任务不算特别复杂。下面我总结一下自己在项目中遇到的一些问题与心得。

## boltdb的使用

boltdb作为一款轻量级的数据库是相当亮眼的。极小的文件大小使得它的运行与维护成本都相当的低，虽然功能与其他大型数据库相比也很基础就是了。有种C语言的感觉，特别是我看到了它允许使用`db.Begin(true)`来自己打开事务的时候。属于那种被大佬使用可以上天，新人勉强用用也不错（容易出bug）的产品。

作为一款数据库产品，它依旧是基于事务的，如果事务没有完成就会回滚。不过因为这款数据库是go语言内部运行的，虽然没有看代码与测试，我认为它在出现操作系统级的错误（断电、被kill）时应该会出现一定的问题，但对于小应用来说并不算什么。

它的API主要包含几个方面，一个是基本的事物操作，通过接受一个函数来增加、删除、查询事务。其中只读事务是可以任意增加的，但同一时间只能够运行一个读写事务，所以应该是一款线程安全的数据库。
```go
读写事务
db.Update(func(tx *bolt.Tx) error)
只读事务
db.View(func(tx *bolt.Tx) error)
```

此外比较亮眼的地方就在于它支持自己开启一个事务
```go
首先使用db.Begin(true)请求一个bolt.Tx的指针
然后通过defer tx.Rollback()在出现问题时回滚
通过bolt.Tx的方法(CreateBucket,Bucket,CreateBucketIfNotExist等)获取bucket，进而对数据进行操作
通过tx.Commit()进行提交
```
可以说是非常的自由了。

它也支持遍历与批处理，这里就不赘述了。总体来说，它是一款成功的轻量级数据库，我个人以为它成功的地方在于提供了一个足够开发者使用的基本功能与可以很方便开发高级功能的接口。这样子有几个好处：
1. 因为源代码的长度有限，开发和维护成本被降低了。（虽然多余的开发成本被转接到了用户身上，我觉得应该也不会有人在意吧。）这使得它可以以很快的速度跟上软件开发的潮流，始终使用最新的技术，如果有的话。
2. 足够的自由与轻量化。大多数时候开发者其实并不需要很复杂的功能，无论是python还是go，它们与传统的C与Java的区别就是足够方便。绝大多数情况下，C语言都是够用的，但为什么不用C语言，就是因为C语言过于复杂。C语言的开发的过程不算简单，但是维护成本异常的高，而且更接近汇编语言而不是人类思维。而go语言则不同，方便易得的多线程和异步调用使得开发过程大大降低，很多优化也更贴近于开发者的视角而不是编译器的视角。因此boltdb是更适合于go的一款数据库，它足够的简洁、轻量却又功能强大。

## go中反射的应用

因为我是使用swapi提供的go接口来采集数据，并将数据存入到boltdb这样的key-value型的数据库中，这就面临着一个问题：我需要用一个泛型的JSON编码器。这个编码器要能够无视各个struct之间的属性区别将其自己变为JSON（因为JSON需要提供类型的方法）这很容易想到用反射reflect来实现，虽然我最后也没有用。但是我积累了很多使用反射来操控的经验，所以在这里总结一下。

反射，指的是go的reflect包中提供的语言特性。go本身是一个强变量的非OO语言，但是它提供了interface{}这个接口，这就使得一个值可以同时具备静态类型与动态类型。用网上的话来说，每个interface变量都对应了一个pair`(value,type)`，其中value是实际的变量值，type是实际的变量类型。那么如何取得实际值。

一种是使用类型判断，比如对于
```
tty,err := os.OpenFile("/sss",os.O_RDWR,0)
var r io.Reader
r = tty

var w io.Writer
w = r.(io.Writer)
//w, ok = r.(io.Writer)

```
其中io.Reader和io.Writer都包含静态类型File*，所以可以这样子转换。如果接口不能转换的话会出现错误，这时候使用注释中的语句是会有ok=false

那如果不清楚具体类型的话怎么办？还可以使用reflect包。

reflect包包含基本的功能TypeOf和ValueOf
* TypeOf用来获取输入参数接口中数据的值，如果接口为空则返回0
* ValueOf用来动态获取输入参数接口中的值的类型，如果接口为0则返回nil

此外两者都还有通过`Interface().(已知类型)`的方法来进行强行转换的功能，与类型判断类似，稍微有一点不符合就是panic.

因此就有了下面代码：
```go
	u := User{Id:1001, Name:"aaa" , addr:"bbb"}
	t := reflect.TypeOf(u)
	v := reflect.ValueOf(u)
	for i := 0; i < v.NumField(); i++ {
		if v.Field(i).CanInterface() {  //判断是否为可导出字段
			fmt.Printf("%s %s = %v -tag:%s \n", 
				t.Field(i).Name, 
				t.Field(i).Type, 
				v.Field(i).Interface(), 
				t.Field(i).Tag)
		}
	}
```
以上代码将结构体u的所有可以导出的字段全部打印出来，如果是key-value型的数据库那么只要用一个map就可以存储了。可以说是相当的方便了。没有使用的原因主要是这样子导入的话处理起来比较麻烦，要将每个value都转换成字符串。考虑到swapi实在太方便了，我直接手动将不同类型的数据一个个转成JSON了（主要是数量太少了，就6个）。但是这个方法实在是挺不错的，所以记录一下。
